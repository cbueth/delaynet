(connectivity_measure)=
# Connectivity Measures

`delaynet` provides a variety of connectivity measures to analyze the relationships between time series.
These measures can be used to detect causal relationships, correlations, and synchronization between different time series.

To measure a significant correlation between two time series,
each connectivity approach calculates a $p$-value.
This $p$-value indicates the probability that the observed correlation
between two time series is due to random chance.
A strong correlation results in a low $p$-value.
Later on, it is possible to prune weak connections based on these $p$-values,
see {ref}`network_pruning`.

One assumption is that the information propagation in the network can have varying
delays between each node in the network.
Due to this, the connectivity needs to be calculated for different delay steps.
It is possible to either test for all delays up to a certain maximum delay,
or to test for specific delays.
The best delay value and it's corresponding $p$-value are returned.

## Using Connectivity Measures

`delaynet` provides a unified interface for all connectivity measures through the {py:func}`~delaynet.connectivity.connectivity` function:

```python
import delaynet as dn

# Calculate connectivity between two time series
result = dn.connectivity(ts1, ts2, metric="linear_correlation", lag_steps=5)
# tests all 1, ...., 5 lags
result = dn.connectivity(ts1, ts2, metric="linear_correlation", lags=[1, 2, 5, 10])
# tests only specified lags
```

Now, `result` is a tuple of the best $p$-value and the corresponding delay step.
For example, if `result` is `(0.05, 3)`, it means that the best $p$-value is 0.05
and it occurs with a lag of 3 time steps.

You can view all available connectivity measures using the {py:func}`~delaynet.connectivity.show_connectivity_metrics()` function:

```python
from delaynet.connectivity import show_connectivity_metrics

# Show all available connectivity measures
show_connectivity_metrics()
```

## Available Connectivity Metrics

`delaynet` provides a diverse set of connectivity metrics to analyze relationships between time series data. Each metric offers different approaches to detecting connections, from simple correlations to complex causality measures. Below is a comprehensive list of all available metrics with their descriptions and usage examples.

### Continuous Ordinal Patterns

The Continuous Ordinal Patterns (COP) connectivity metric analyzes the patterns in time series data to detect relationships.

```python
import delaynet as dn

# Calculate COP connectivity
result = dn.connectivity(ts1, ts2, metric="random_patterns", p_size=5, num_rnd_patterns=50, lag_steps=5)
```

Parameters:
- `p_size`: Size of the ordinal pattern
- `num_rnd_patterns`: Number of random patterns to consider
- `lag_steps`: Time lags to consider. An integer will consider lags [1, ..., lag_steps]. Passing a list will consider the specified values as lags.

### Granger Causality

Granger Causality (GC) is a statistical concept of causality based on prediction.
If a time series X "Granger-causes" a time series Y, then past values of X should contain information that helps predict Y beyond the information contained in past values of Y alone
{cite:p}`zaninAssessingGrangerCausality2021`.
Before using Granger Causality, it's important to detrend the time series data to avoid spurious results.

```python
import delaynet as dn

# Calculate single-lag Granger Causality
result = dn.connectivity(ts1, ts2, metric="granger causality", lag_steps=5)
```

### Linear Correlation

The Linear Correlation (LC) connectivity metric calculates the Pearson correlation coefficient between two time series.

```python
import delaynet as dn

# Calculate linear correlation
result = dn.connectivity(ts1, ts2, metric="linear_correlation", lag_steps=5, return_abs=True)
```

Parameters:
- `lag_steps`: Time lags to consider. An integer will consider lags [1, ..., lag_steps]. Passing a list will consider the specified values as lags.
- `return_abs`: Whether to return the absolute value of the correlation

### Mutual Information

Mutual Information (MI) measures the amount of information obtained about one random variable through observing another random variable.

```python
import delaynet as dn

# Calculate mutual information
result = dn.connectivity(ts1, ts2, metric="mutual_information", approach="kernel", lag_steps=5)
```

Parameters:
- `approach`: The approach to use for estimating mutual information (see `infomeasure.mutual_information` for available approaches)
- `lag_steps`: Time lags to consider. An integer will consider lags [1, ..., lag_steps]. Passing a list will consider the specified values as lags.

### Ordinal Synchronization

The Ordinal Synchronization (OS) connectivity metric measures the synchronization between two time series based on their ordinal patterns.

```python
import delaynet as dn

# Calculate ordinal synchronization
result = dn.connectivity(ts1, ts2, metric="ordinal_synchronization", d=3, tau=1, lag_steps=5)
```

Parameters:
- `d`: Embedding dimension / delay dimension
- `tau`: OS time delay
- `lag_steps`: Time lags to consider. An integer will consider lags [1, ..., lag_steps]. Passing a list will consider the specified values as lags.

### Rank Correlation

The Rank Correlation (RC) connectivity metric calculates the Spearman rank correlation between two time series.

```python
import delaynet as dn

# Calculate rank correlation
result = dn.connectivity(ts1, ts2, metric="rank_correlation", lag_steps=5)
```

Parameters:
- `lag_steps`: Time lags to consider. An integer will consider lags [1, ..., lag_steps]. Passing a list will consider the specified values as lags.

### Transfer Entropy

Transfer Entropy (TE) measures the amount of directed transfer of information between two random processes.

```python
import delaynet as dn

# Calculate transfer entropy
result = dn.connectivity(ts1, ts2, metric="transfer_entropy", approach="discrete")
```

Parameters:
- `approach`: The approach to use for estimating transfer entropy (see `infomeasure.transfer_entropy` for available approaches)

### Gravity

```{note}
How useful is this one?
```

The Gravity connectivity metric calculates a measure of interaction between two time series based on the product of their exponential sums.
This is a toy metric that may not have practical applications but can serve as an educational tool.

```python
import delaynet as dn

# Calculate gravity
result = dn.connectivity(ts1, ts2, metric="gravity", lag_steps=5)
```


Parameters:
- `lag_steps`: Time lags to consider. An integer will consider lags [1, ..., lag_steps]. Passing a list will consider the specified values as lags.
