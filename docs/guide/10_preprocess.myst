---
file_format: mystnb
kernelspec:
  name: python3
---

(preprocessing)=
# Preprocessing

This section covers the preprocessing functionality in `delaynet`, which includes handling data before analysis.

```{attention}
When working with time series data, it's important to check for NaN values and missing data before analysis.
`delaynet` currently doesn't provide specific functions for handling NaN values or missing data.
When preprocessing your data, make sure you choose a method that best suits your dataset and research question,
e.g. replacing NaNs with zeros, mean, median imputation, or using interpolation methods.
```

## Data cleaning
Before performing any {ref}`normalisation <norm_methods>` and {ref}`connectivity analysis <connectivity_measure>`,
it's crucial to clean the data. This includes handling missing values and outliers.

### Handling Missing Values

Missing values can be handled by filling them with a specific value or method like mean imputation:

```{code-cell}
import numpy as np

# Sample data with missing values
data = np.array([10.0, 20.0, None, np.nan, 50.0], dtype=np.float64)

# Fill missing values - in-place replacement
np.nan_to_num(data, nan=0.0, copy=False)
data
```

```{warning}
**Work in progress:** We do have {ref}`Symbolization` but might get rid of it.
Do we really want to include any preprocessing functions?
I suggest we have this page that informs the user about possible preprocessing and hilight the need for preprocessing.
But `delaynet` does not need to have any preprocessing functions.

**TODO:** Change this document accordingly.
```

## Symbolization

Many entropy-based connectivity metrics in `delaynet` require symbolic (discrete) time series. The `delaynet.preprocess.symbolic` module provides several functions to convert continuous time series to symbolic form.

### Converting to Symbolic Form

The main function for converting time series to symbolic form is `to_symbolic()`, which serves as a wrapper for different symbolization methods:

```python
from delaynet.preprocess.symbolic import to_symbolic
import numpy as np

# Create a sample time series
ts = np.array([1.1, 2.2, 3.3, 4.4, 5.5])

# Convert to symbolic using different methods
symbolic_ts1 = to_symbolic(ts, method="quantize", max_symbols=3)
symbolic_ts2 = to_symbolic(ts, method="quantilize", num_quantiles=3)
symbolic_ts3 = to_symbolic(ts, method="binarize", threshold=3.0)
symbolic_ts4 = to_symbolic(ts, method="round_to_int")
```

### Symbolization Methods

`delaynet` provides several methods for symbolization:

#### Quantize

The `quantize()` function converts a time series to symbolic form by digitizing it into a specified number of bins:

```python
from delaynet.preprocess.symbolic import quantize
import numpy as np

ts = np.array([1.0, 2.0, 3.0, 4.0])
symbolic_ts = quantize(ts, max_symbols=2)  # Result: [0, 0, 1, 1]
```

This function linearly scales the time series to the range [0, max_symbols-1] and rounds to the nearest integer.

#### Quantilize

The `quantilize()` function converts a time series to symbolic form using quantiles:

```python
from delaynet.preprocess.symbolic import quantilize
import numpy as np

ts = np.array([1, 2, 3, 3, 3, 3, 3, 3, 4, 5, 6, 7])
symbolic_ts = quantilize(ts, num_quantiles=3)  # Result: [0, 0, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2]
```

Unlike `quantize()`, which uses equal-sized bins, `quantilize()` creates bins based on the distribution of the data, ensuring each bin contains approximately the same number of data points.

#### Binarize

The `binarize()` function converts a time series to binary form based on a threshold:

```python
from delaynet.preprocess.symbolic import binarize
import numpy as np
from operator import lt

ts = np.array([1.0, 2.0, 3.0, 4.0])
symbolic_ts1 = binarize(ts, threshold=2.5)  # Result: [0, 0, 1, 1]
symbolic_ts2 = binarize(ts, threshold=lambda x: x.mean())  # Result: [0, 0, 1, 1]
symbolic_ts3 = binarize(ts, threshold=2.5, operator=lt)  # Result: [1, 1, 0, 0]
```

The threshold can be a fixed value or a function that computes a value from the time series (e.g., mean or median).

#### Round to Integer

The `round_to_int()` function simply rounds each value in the time series to the nearest integer:

```python
from delaynet.preprocess.symbolic import round_to_int
import numpy as np

ts = np.array([1.1, 2.2, 3.3])
symbolic_ts = round_to_int(ts)  # Result: [1, 2, 3]
```

### Checking Symbolic Time Series

`delaynet` also provides a function to check if time series are in symbolic form:

```python
from delaynet.preprocess.symbolic import check_symbolic_pairwise
import numpy as np

ts1 = np.array([1, 2, 3], dtype=int)
ts2 = np.array([2, 3, 4], dtype=int)
check_symbolic_pairwise(ts1, ts2, max_symbols=5)  # No error if valid
```

This function checks if two time series are in symbolic form (integer type) and if they together don't have more than a specified number of unique symbols.
